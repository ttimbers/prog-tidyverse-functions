---
title: "prog-tidyverse-functions"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

> **Attribution:** Derived from the [Programming with {dplyr} vignette](https://dplyr.tidyverse.org/articles/programming.html) by Hadley Wickham, Romain François, Lionel Henry, Kirill Müller, and RStudio.

Most dplyr verbs use **tidy evaluation** in some way. Tidy evaluation is a special type of non-standard evaluation used throughout the tidyverse. There are two basic forms found in dplyr:

* `arrange()`, `count()`, `filter()`, `group_by()`, `mutate()`, and 
  `summarise()` use **data masking** so that you can use data variables as if 
  they were variables in the environment (i.e. you write `my_variable` not
  `df$myvariable`). 

* `across()`, `relocate()`, `rename()`, `select()`, and `pull()` use 
  **tidy selection** so you can easily choose variables based on their position, 
  name, or type (e.g. `starts_with("x")` or `is.numeric`).

To determine whether a function argument uses data masking or tidy selection, look at the documentation: in the arguments list, you'll see `<data-masking>` or `<tidy-select>`.

Data masking and tidy selection make interactive data exploration fast and fluid, but they add some new challenges when you attempt to use them indirectly such as in a for loop or a function. This vignette shows you how to overcome those challenges. We'll first go over the basics of data masking and tidy selection, talk about how to use them indirectly, and then show you a number of recipes to solve common problems.

This vignette will give you the minimum knowledge you need to be an effective programmer with tidy evaluation. If you'd like to learn more about the underlying theory, or precisely how it's different from non-standard evaluation, we recommend that you read the Metaprogramming chapters in [_Advanced R_](https://adv-r.hadley.nz).

Before we get started, let's load the tidyverse packages:
```{r load tidyverse, message = FALSE}
library(tidyverse)
```

## Data masking

Data masking makes data manipulation faster because it requires less typing. In most (but not all[^subset]) base R functions you need to refer to variables with `$`, leading to code that repeats the name of the data frame many times:

```{r, results = FALSE}
starwars[starwars$homeworld == "Naboo" & starwars$species == "Human", ,]
```

[^subset]: dplyr's `filter()` is inspired by base R's `subset()`. `subset()` provides data masking, but not with tidy evaluation, so the techniques described in this chapter don't apply to it.

The dplyr equivalent of this code is more concise because data masking allows you to need to type `starwars` once:

```{r, results = FALSE}
starwars %>% filter(homeworld == "Naboo", species == "Human")
```

### Data- and env-variables 

The key idea behind data masking is that it blurs the line between the two different meanings of the word "variable":

* **env-variables** are "programming" variables that live in an environment.
  They are usually created with `<-`. 

* **data-variables** are "statistical" variables that live in a data frame.
  They usually come from data files (e.g. `.csv`, `.xls`), or are created 
  manipulating existing variables. 
  
To make those definitions a little more concrete, take this piece of code:

```{r}
df <- data.frame(x = runif(3), y = runif(3))
df$x
```

It creates a env-variable, `df`, that contains two data-variables, `x` and `y`. Then it extracts the data-variable `x` out of the env-variable `df` using `$`.

I think this blurring of the meaning of "variable" is a really nice feature for interactive data analysis because it allows you to refer to data-vars as is, without any prefix. And this seems to be fairly intuitive since many newer R users will attempt to write `diamonds[x == 0 | y == 0, ]`. 

Unfortunately, this benefit does not come for free. When you start to program with these tools, you're going to have to grapple with the distinction. This will be hard because you've never had to think about it before, so it'll take a while for your brain to learn these new concepts and categories. However, once you've teased apart the idea of "variable" into data-variable and env-variable, I think you'll find it fairly straightforward to use.

### Indirection

The main challenge of programming with functions that use data masking arises when you introduce some indirection, i.e. when you want to get the data-variable from an env-variable instead of directly typing the data-variable's name. There are two main cases:

*   When you have the data-variable in a function argument (i.e. an env-variable
    that holds a promise[^promise]), you need to **embrace** the argument by
    surrounding it in doubled braces, like `filter(df, {{ var }})`.
    
    The following function uses embracing to create a wrapper around 
    `summarise()` that computes the minimum and maximum values of a variable,
    as well as the number of observations that were summarised:

    ```{r, results = FALSE}
    var_summary <- function(data, var) {
      data %>%
        summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
    }
    mtcars %>% 
      group_by(cyl) %>% 
      var_summary(mpg)
    ```

*   When you have an env-variable that is a character vector, you need to index 
    into the `.data` pronoun with `[[`, like 
    `summarise(df, mean = mean(.data[[var]]))`.
    
    The following example uses `.data` to count the number of unique values in
    each variable of `mtcars`:

    ```{r, results = FALSE}
    for (var in names(mtcars)) {
      mtcars %>% count(.data[[var]]) %>% print()
    }
    ```

    Note that `.data` is not a data frame; it's a special construct, a pronoun, 
    that allows you to access the current variables either directly, with 
    `.data$x` or indirectly with `.data[[var]]`. Don't expect other functions 
    to work with it.

[^promise]: In R, arguments are lazily evaluated which means that until you attempt to use, they don't hold a value, just a __promise__ that describes how to compute the value. You can learn more at <https://adv-r.hadley.nz/functions.html#lazy-evaluation>

## Tidy selection

Data masking makes it easy to compute on values within a dataset. Tidy selection is a complementary tool that makes it easy to work with the columns of a dataset.

### The tidyselect DSL

Underneath all functions that use tidy selection is the [tidyselect](https://tidyselect.r-lib.org/) package. It provides a miniature domain specific language that makes it easy to select columns by name, position, or type. For example:

* `select(df, 1)` selects the first column; 
  `select(df, last_col())` selects the last column.
  
* `select(df, c(a, b, c))` selects columns `a`, `b`, and `c`.

* `select(df, starts_with("a"))` selects all columns whose name starts with "a";
  `select(df, ends_with("z"))` selects all columns whose name ends with "z".
  
* `select(df, where(is.numeric))` selects all numeric columns.

You can see more details in `?dplyr_tidy_select`.

### Indirection

As with data masking, tidy selection makes a common task easier at the cost of making a less common task harder. When you want to use tidy select indirectly with the column specification stored in an intermediate variable, you'll need to learn some new tools. Again, there are two forms of indirection:

*   When you have the data-variable in an env-variable that is a function
    argument, you use the same technique as data masking: you **embrace** the
    argument by surrounding it in doubled braces.
    
    The following function summarises a data frame by computing
    the mean of all variables selected by the user:

    ```{r, results = FALSE}
    summarise_mean <- function(data, vars) {
      data %>% summarise(n = n(), across({{ vars }}, mean))
    }
    mtcars %>% 
      group_by(cyl) %>% 
      summarise_mean(where(is.numeric))
    ```

*   When you have an env-variable that is a character vector, you need to use
    `all_of()` or `any_of()` depending on whether you want the
    function to error if a variable is not found. 
    
    The following code uses `all_of()` to select all of the variables found
    in a character vector; then `!` plus `all_of()` to select all of the 
    variables *not* found in a character vector:

    ```{r, results = FALSE}
    vars <- c("mpg", "vs")
    mtcars %>% select(all_of(vars))
    mtcars %>% select(!all_of(vars))
    ```